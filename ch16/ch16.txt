chapter 16
==========

### Linked Lists

*Final exam covers ch 13-17.*

**All of the collections in this course us one of the following two underlying data structures:**

  - Array
    - *ArrayList, Stack, HashSet, HashMap*
  - Linked Objects
    - *LinkedList, TreeSet, TreeMap*

**Linked Objects** store an element and one or more references to other elements:

**Head**->`element|next`->`element|next`->`element|next`->**Tail** *(End ref points null)*.

A linked list is a data structure that stores an ordered sequence of elements using a chain of objects called **nodes**. Each 
node refers to at least one other node in the list. A node has a *data* and *next* field. You can connect one node to another by assigning
its *next* field to another node. 

#### List Node

ListNode is a class for storing a single node of a linked list, as a list is composed of nodes [data, next].

```java 
public class ListNode {
	int data;
	ListNode next; // class defined recursively 
}
```

In this example each list node object stores one piece of integer data and a reference to another list node. 
**ListNodes** are linked together into chains to store lists of values. A ListNode class w/ practical constructors would look like:

```java 
public class ListNode {
	int data;
	ListNode next;
	// default constructor in use

	// supplied constructors
	public ListNode(){
		this(0, null);
	}
	public ListNode(int data){
		this(data, null);
	}
	public ListNode(int data, ListNode next){
		this.data = data;
		this.next = next;
	}
}
```

With which a declaration of a new Linked List such as:

```java

ListNode list = new ListNode(42, new ListNode(43, new ListNode(44)));

```

is entirely valid and creates a list of `42, 43, 44` with appropriate links, final node terminating `null`. It can be seen
that the list itself is a data structure abstracted from the individual nodes, defined recursively. 

#### List Traversal

Traversing a linked list is accomplished through the use of node pointers, or otherwise *ListNode variables*. References to 
`head`, `curr`, and `tail` are very useful in manipulating lists and can be created by assignment:

```java

ListNode curr = list;

```

The list can then be traversed by walking the reference until next points to `null`;

```java

while(curr!=null){
	System.out.println(curr.data);
	curr = curr.next;
}

```

In the implementation of the LinkedList class, a `null head` would signify an empty list, or otherwise `head==tail`.
Sorting, insertion, removal, et al operations must check for null condition to avoid null pointer exceptions.
Adding to a list requires traversal of the list to the end:


```java
	public void add(int value){
		if(head==null)
			head = new ListNode(value);
		else {
			ListNode curr = head;
			// traverse to end
			while(curr.next!=null){
				curr = curr.next;
			}
			// add node at end 
			curr.next = new ListNode(value);
		}	
	}
```

Returning the head and tail of the list itself requires similar checks and traversals:

```java

	public ListNode head(){
		return head;
	}
	public ListNode tail(){
		if(head==null)
			return head;
		else {
			ListNode curr = head;
			// traverse to end
			while(curr.next!=null){
				curr = curr.next;
			}
		return curr;
		}
	}
``` 